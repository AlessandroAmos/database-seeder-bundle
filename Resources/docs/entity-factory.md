## Defining entity factories

To define a seed factory, you should create a class that extends
the `Alms\Bundle\DatabaseSeederBundle\Factory\AbstractFactory`
class.

Here is an example of a seed factory that defines a `User` entity:

```php
namespace Database\Factory;

use App\Entity\User;
use Alms\Bundle\DatabaseSeederBundle\Factory\AbstractFactory;
use Alms\Bundle\DatabaseSeederBundle\Factory\FactoryInterface;

/**
 * @implements FactoryInterface<User>
 */
final class UserFactory extends AbstractFactory implements FactoryInterface
{
    public function entity(): string
    {
        return User::class;
    }
    
    public function makeEntity(array $definition): User
    {
        return new User(
            firstName: $definition['firstName'],
            lastName: $definition['lastName'],
            birthday: $definition['birthday'],
        );
    }

    public function definition(): array
    {
        return [
            'firstName' => $this->faker->firstName(),
            'lastName' => $this->faker->lastName(),
            'birthday' => \DateTimeImmutable::createFromMutable($this->faker->dateTime()),
            'comments' => CommentFactory::new()->times(3)->make(), // Can use other factories.
            // Be careful, circular dependencies are not allowed!
        ];
    }
}
```

The `entity` method should return the fully qualified class name of the target entity that the factory is responsible
for creating. In some cases, the factory may use the class name returned by the `entity` method to create a new instance
of the entity without calling its constructor. Instead, it may use reflection to directly set the properties of the
entity using data from the `definition` method.

The `makeEntity` method allows you to control the process of creating an entity through its constructor. The method
takes an array of definitions as an argument, which is generated by the `definition` method.

The `definition` method is where you can define all of the properties of the entity. The method should return an array
where the keys are the property names and the values are the values that should be set for those properties. These
values can be hard-coded or generated using the [Faker](https://fakerphp.github.io/) library, which provides a wide
range of fake data generation methods such as names, addresses, phone numbers, etc. This method is responsible for
generating the definition array that will be passed to the makeEntity method to construct the entity object or used to
set properties directly.

## Using entity factory

A factory can be created by calling the `new` method on the factory class:

```php
use Database\Factory\UserFactory;

$factory = UserFactory::new();
```

This will create a new instance of the factory. It provides several useful methods for generating entities.

You can also pass an array of definition to the new method of the factory class.

```php
use Database\Factory\UserFactory;

$factory = UserFactory::new(['admin' => true]);
```

This is a useful feature when you have a common set of definitions that you want to use across multiple factories or
when you want to set a default value for a property that will be overridden in specific cases.

### Create entities

The `create` method creates an array of entities, stores them in the database and returns them for further use in the
code.

```php
$users = $factory->times(10)->create();
```

The `createOne` method creates a single entity, stores it in the database and returns it for further use in the code.

```php
$user = $factory->createOne();
```

### Make entities

The `make` method creates an array of entities and returns them for further use in code, but does not store them in
the database.

```php
$users = $factory->times(10)->make();
```

The `makeOne` method creates a single entity and returns it for further use in code, but does not store it in the
database.

```php
$user = $factory->makeOne();
```

### Entity states

The `state` method allows developers to easily define specific states for entities. It can be used to set a specific set
of properties on an entity when it is created. The returned values from the closure will replace the corresponding
values in the definition array, allowing developers to easily change the state of an entity in a specific way.

> **Note**
> It is non-destructive, it will only update the properties passed in the returned array and will not remove
> any properties from the definition array.

```php
$factory->state(fn(\Faker\Generator $faker, array $definition) => [
    'admin' => $faker->boolean(),
])->times(10)->create();
```

In addition to the `state` method, there also the `entityState` method. This method allows developers to change the
state of an entity object using the available methods of that entity. It takes a closure as an argument, which should
accept the entity as an argument and should return the modified entity. This allows developers to take full advantage of
the object-oriented nature of their entities and use the methods that are already defined on the entity to change its
state.

```php
$factory->entityState(static function(User $user) {
    return $user->markAsDeleted();
})->times(10)->create();
```

The `state` and `entityState` methods can be used inside a factory class to create additional methods for creating
entities with specific states. By creating these additional methods, developers can create a more expressive and
readable code, and make it easier to understand the intent of the code.

```php
final class UserFactory extends AbstractFactory
{
    // ....

    public function admin(): self
    {
        return $this->state(fn(\Faker\Generator $faker, array $definition) => [
            'admin' => true,
        ]);
    }
    
    public function fromCity(string $city): self
    {
        return $this->state(fn(\Faker\Generator $faker, array $definition) => [
            'city' => $city,
        ]);
    }
    
    public function deleted(): self
    {
        return $this->entityState(static function (User $user) {
            return $user->markAsDeleted();
        });
    }
    
    public function withBirthday(\DateTimeImmutable $date): self
    {
        return $this->entityState(static function (User $user) use ($date) {
            $user->birthday = $date;
            return $user;
        });
    }
}
```

And example of using these methods:

```php
$factory->admin()
    ->fromCity('New York')
    ->deleted()
    ->withBirthday(new \DateTimeImmutable('2010-01-01 00:00:00'))
    ->times(10)
    ->create();
```

Factories can be used in your feature test cases to create entities in the database without seeding. This can be
useful in situations where you want to create a specific set of test data for a feature test, or when you want to test
the behavior of your application with a specific set of data.

Here is an example of using a factory in a feature test case:

```php
final class UserServiceTest extends KernelTestCase
{
    // ...

    public function testDeleteUser(): void
    {
        $user = UserFactory::new()
            ->fromCity('New York')
            ->createOne();

        $this->userService->delete(
            uuid: $user->uuid,
        );

        $this->assertEntity(User::class)->where([
            'uuid' => (string)$user->uuid,
            'deleted_at' => ['!=' => null],
        ])->assertExists();
    }
}
```
